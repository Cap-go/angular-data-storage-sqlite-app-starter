{"ast":null,"code":"import _asyncToGenerator from \"/Users/queaujeanpierre/Development/latest/angular-data-storage-sqlite-app-starter/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { WebPlugin } from '@capacitor/core';\nimport { Data } from './web-utils/Data';\nimport { StorageDatabaseHelper } from './web-utils/StorageDatabaseHelper';\nimport { isJsonStore } from './web-utils/json-utils';\nexport class CapacitorDataStorageSqliteWeb extends WebPlugin {\n  echo(options) {\n    return _asyncToGenerator(function* () {\n      const ret = {};\n      ret.value = options.value ? options.value : '';\n      return ret;\n    })();\n  }\n\n  openStore(options) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const dbName = options.database ? `${options.database}IDB` : 'storageIDB';\n      const tableName = options.table ? options.table : 'storage_store';\n\n      try {\n        _this.mDb = new StorageDatabaseHelper(dbName, tableName);\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(`OpenStore: ${err.message}`);\n      }\n    })();\n  }\n\n  closeStore(options) {\n    return _asyncToGenerator(function* () {\n      throw new Error(`Method closeStore not implemented. ${options}`);\n    })();\n  }\n\n  isStoreOpen(options) {\n    return _asyncToGenerator(function* () {\n      throw new Error(`Method isStoreOpen not implemented. ${options}`);\n    })();\n  }\n\n  isStoreExists(options) {\n    return _asyncToGenerator(function* () {\n      throw new Error(`Method isStoreExists not implemented. ${options}`);\n    })();\n  }\n\n  setTable(options) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const tableName = options.table;\n\n      if (tableName == null) {\n        return Promise.reject('SetTable: Must provide a table name');\n      }\n\n      if (_this2.mDb) {\n        try {\n          yield _this2.mDb.setTable(tableName);\n          return Promise.resolve();\n        } catch (err) {\n          return Promise.reject(`SetTable: ${err.message}`);\n        }\n      } else {\n        return Promise.reject('SetTable: Must open a store first');\n      }\n    })();\n  }\n\n  set(options) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const key = options.key;\n\n      if (key == null || typeof key != 'string') {\n        return Promise.reject('Set: Must provide key as string');\n      }\n\n      const value = options.value ? options.value : null;\n\n      if (value == null || typeof value != 'string') {\n        return Promise.reject('Set: Must provide value as string');\n      }\n\n      const data = new Data();\n      data.name = key;\n      data.value = value;\n\n      try {\n        yield _this3.mDb.set(data);\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(`Set: ${err.message}`);\n      }\n    })();\n  }\n\n  get(options) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const key = options.key;\n\n      if (key == null || typeof key != 'string') {\n        return Promise.reject('Get: Must provide key as string');\n      }\n\n      try {\n        const data = yield _this4.mDb.get(key);\n\n        if ((data === null || data === void 0 ? void 0 : data.value) != null) {\n          return Promise.resolve({\n            value: data.value\n          });\n        } else {\n          return Promise.resolve({\n            value: ''\n          });\n        }\n      } catch (err) {\n        return Promise.reject(`Get: ${err.message}`);\n      }\n    })();\n  }\n\n  remove(options) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const key = options.key;\n\n      if (key == null || typeof key != 'string') {\n        return Promise.reject('Remove: Must provide key as string');\n      }\n\n      try {\n        yield _this5.mDb.remove(key);\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(`Remove: ${err.message}`);\n      }\n    })();\n  }\n\n  clear() {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this6.mDb.clear();\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(`Clear: ${err.message}`);\n      }\n    })();\n  }\n\n  iskey(options) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      const key = options.key;\n\n      if (key == null || typeof key != 'string') {\n        return Promise.reject('Iskey: Must provide key as string');\n      }\n\n      try {\n        const ret = yield _this7.mDb.iskey(key);\n        return Promise.resolve({\n          result: ret\n        });\n      } catch (err) {\n        return Promise.reject(`Iskey: ${err.message}`);\n      }\n    })();\n  }\n\n  keys() {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const ret = yield _this8.mDb.keys();\n        return Promise.resolve({\n          keys: ret\n        });\n      } catch (err) {\n        return Promise.reject(`Keys: ${err.message}`);\n      }\n    })();\n  }\n\n  values() {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const ret = yield _this9.mDb.values();\n        return Promise.resolve({\n          values: ret\n        });\n      } catch (err) {\n        return Promise.reject(`Values: ${err.message}`);\n      }\n    })();\n  }\n\n  filtervalues(options) {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      const filter = options.filter;\n\n      if (filter == null || typeof filter != 'string') {\n        return Promise.reject('Filtervalues: Must provide filter as string');\n      }\n\n      let regFilter;\n\n      if (filter.startsWith('%')) {\n        regFilter = new RegExp('^' + filter.substring(1), 'i');\n      } else if (filter.endsWith('%')) {\n        regFilter = new RegExp(filter.slice(0, -1) + '$', 'i');\n      } else {\n        regFilter = new RegExp(filter, 'i');\n      }\n\n      try {\n        const ret = [];\n        const results = yield _this10.mDb.keysvalues();\n\n        for (const result of results) {\n          if (result.name != null && regFilter.test(result.name)) {\n            if (result.value != null) {\n              ret.push(result.value);\n            } else {\n              return Promise.reject(`Filtervalues: result.value is null`);\n            }\n          }\n        }\n\n        return Promise.resolve({\n          values: ret\n        });\n      } catch (err) {\n        return Promise.reject(`Filtervalues: ${err.message}`);\n      }\n    })();\n  }\n\n  keysvalues() {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const ret = [];\n        const results = yield _this11.mDb.keysvalues();\n\n        for (const result of results) {\n          if (result.name != null && result.value != null) {\n            const res = {\n              key: result.name,\n              value: result.value\n            };\n            ret.push(res);\n          } else {\n            return Promise.reject(`Keysvalues: result.name/value are null`);\n          }\n        }\n\n        return Promise.resolve({\n          keysvalues: ret\n        });\n      } catch (err) {\n        return Promise.reject(`Keysvalues: ${err.message}`);\n      }\n    })();\n  }\n\n  deleteStore(options) {\n    return _asyncToGenerator(function* () {\n      throw new Error(`Method deleteStore not implemented. ${options}`);\n    })();\n  }\n\n  isTable(options) {\n    var _this12 = this;\n\n    return _asyncToGenerator(function* () {\n      const table = options.table;\n\n      if (table == null) {\n        return Promise.reject('Must provide a Table Name');\n      }\n\n      try {\n        const ret = yield _this12.mDb.isTable(table);\n        return Promise.resolve({\n          result: ret\n        });\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  tables() {\n    var _this13 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const ret = yield _this13.mDb.tables();\n        return Promise.resolve({\n          tables: ret\n        });\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n\n  deleteTable(options) {\n    return _asyncToGenerator(function* () {\n      throw new Error(`Method deleteTable not implemented. ${options}`);\n    })();\n  }\n\n  importFromJson(options) {\n    var _this14 = this;\n\n    return _asyncToGenerator(function* () {\n      const keys = Object.keys(options);\n\n      if (!keys.includes('jsonstring')) {\n        return Promise.reject('Must provide a json object');\n      }\n\n      let totalChanges = 0;\n\n      if (options === null || options === void 0 ? void 0 : options.jsonstring) {\n        const jsonStrObj = options.jsonstring;\n        const jsonObj = JSON.parse(jsonStrObj);\n        const isValid = isJsonStore(jsonObj);\n\n        if (!isValid) {\n          return Promise.reject('Must provide a valid JsonSQLite Object');\n        }\n\n        const vJsonObj = jsonObj;\n        const dbName = vJsonObj.database ? `${vJsonObj.database}IDB` : 'storageIDB';\n\n        for (const table of vJsonObj.tables) {\n          const tableName = table.name ? table.name : 'storage_store';\n\n          try {\n            _this14.mDb = new StorageDatabaseHelper(dbName, tableName); // Open the database\n\n            const bRet = _this14.mDb.openStore(dbName, tableName);\n\n            if (bRet) {\n              // Import the JsonSQLite Object\n              if (table === null || table === void 0 ? void 0 : table.values) {\n                const changes = yield _this14.mDb.importJson(table.values);\n                totalChanges += changes;\n              }\n            } else {\n              return Promise.reject(`Open store: ${dbName} : table: ${tableName} failed`);\n            }\n          } catch (err) {\n            return Promise.reject(`ImportFromJson: ${err.message}`);\n          }\n        }\n\n        return Promise.resolve({\n          changes: totalChanges\n        });\n      } else {\n        return Promise.reject('Must provide a json object');\n      }\n    })();\n  }\n\n  isJsonValid(options) {\n    return _asyncToGenerator(function* () {\n      const keys = Object.keys(options);\n\n      if (!keys.includes('jsonstring')) {\n        return Promise.reject('Must provide a json object');\n      }\n\n      if (options === null || options === void 0 ? void 0 : options.jsonstring) {\n        const jsonStrObj = options.jsonstring;\n        const jsonObj = JSON.parse(jsonStrObj);\n        const isValid = isJsonStore(jsonObj);\n\n        if (!isValid) {\n          return Promise.reject('Stringify Json Object not Valid');\n        } else {\n          return Promise.resolve({\n            result: true\n          });\n        }\n      } else {\n        return Promise.reject('Must provide in options a stringify Json Object');\n      }\n    })();\n  }\n\n  exportToJson() {\n    var _this15 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const ret = yield _this15.mDb.exportJson();\n        return Promise.resolve({\n          export: ret\n        });\n      } catch (err) {\n        return Promise.reject(`exportToJson: ${err}`);\n      }\n    })();\n  }\n\n} //# sourceMappingURL=web.js.map","map":null,"metadata":{},"sourceType":"module"}